{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Lazurite is an unofficial shader development tool for Minecraft: Bedrock Edition with RenderDragon graphics engine, which focuses on intuitive use and powerful features.</p> <p>GitHub page: https://github.com/veka0/lazurite</p> <p>PyPi page: https://pypi.org/project/lazurite</p>"},{"location":"#installation","title":"Installation","text":"<p>Lazurite requires to have Python 3.10+ installed, but 3.12 is recommended.</p> <p>Official python installation page: https://www.python.org/downloads. Windows users are recommended to install Python from Microsoft Store.</p> <p>After installing python, you can install lazurite package from pypi repository, with a command</p> <pre><code>pip install lazurite\n</code></pre> <p>or</p> <pre><code>python -m pip install lazurite\n</code></pre> Termux installation error <p>If during Lazurite installation on Termux (Android) you encounter this error:</p> <pre><code>aarch64-linux-android-clang++: error: unknown argument: '-fno-openmp-implicit-rpath'\n      error: command '/data/data/com.termux/files/usr/bin/aarch64-linux-android-clang++' failed with exit code 1\n      note: This error originates from a subprocess, and is likely not a problem with pip.\n\nERROR: Failed building wheel for pyjson5\nFailed to build pycryptodome pyjson5\nERROR: Could not build wheels for pycryptodome, pyjson5, which is required to install pyproject.toml-based projects\n</code></pre> <p>It can be fixed by running the following commands (as suggested here):</p> <pre><code>_file=\"$(find $PREFIX/lib/python3.11 -name \"_sysconfigdata*.py\")\"\nrm -rf $PREFIX/lib/python3.11/__pycache__\ncp $_file \"$_file\".backup\nsed -i 's|-fno-openmp-implicit-rpath||g' \"$_file\"\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<p>Try making your first shader or learn about available commands, unpacked material syntax and how project compilation works.</p>"},{"location":"commands/","title":"Commands","text":"<p>The main way of interacting with lazurite is a command line interface, which can have different syntax, depending on the installation method</p> <pre><code>lazurite COMMAND [INPUTS ...] [ARGUMENTS ...]\n</code></pre> <pre><code>lazurite.exe COMMAND [INPUTS ...] [ARGUMENTS ...]\n</code></pre> <pre><code>python -m lazurite COMMAND [INPUTS ...] [ARGUMENTS ...]\n</code></pre> <p>Here is a cheatsheet of what each command does</p> Command Description unpack Unpacks input materials pack Packs materials back into <code>material.bin</code> files label Adds a comment with debug information to plain text shaders (GLSL, ESSL, Metal) clear Clears compiled shaders in materials, while removing encryption convert Converts between <code>.material.bin</code> file format versions restore Restores GLSL or SC source code from Android materials and varying.def.sc from any materials build Compiles all materials and shaders in a project info Displays useful information about input material serialize Generates minimal json from material bin files that can be used as merge source"},{"location":"commands/#unpack","title":"unpack","text":"<pre><code>lazurite unpack [MATERIALS ...] [--sort-flags] [--skip-shaders] [-o OUTPUT]\n</code></pre> Argument Description Default <code>--sort-flags</code> Sorts variants and flags alphabeticaly <code>--skip-shaders</code> Don't unpack compiled shaders <code>-o</code> <code>--output</code> Output folder, where materials will be unpacked current directory <p>Warning</p> <p>This command won't unpack compiled shaders from encrypted materials (RTXStub)</p> <p>This command unpacks input materials (<code>material.bin</code> files). You can specify multiple materials or folders with material files. By default, it will unpack into current working directory, but optional <code>--output</code> argument can be used to specify output directory instead. <code>--sort-flags</code> can be used to sort flags within variants and variants by flags, which might be useful when diffing unpacked materials. See material format for details on the unpacked material format.</p> <p>Example usage</p> <pre><code>lazurite unpack Actor.bin folderWithMaterials/ RenderChunk.bin --sort-flags -o outputFolder/\n</code></pre> <p>This command will unpack <code>Actor.bin</code>, <code>RenderChunk.bin</code> and all materials in <code>folderWithMaterials/</code> into the <code>outputFolder/</code> while sorting their variants and flags.</p>"},{"location":"commands/#pack","title":"pack","text":"<pre><code>lazurite pack [MATERIALS ...] [-o OUTPUT]\n</code></pre> Argument Description Default <code>-o</code> <code>--output</code> Output folder, where packed materials will be stored current directory <p>This command packs unpacked input materials back into <code>material.bin</code> files. You can specify as an input:</p> <ol> <li>Path to <code>material.json</code> file inside of unpacked material folder</li> <li>Path to unpacked material folder (if it has <code>material.json</code> inside)</li> <li>Path to a folder with unpacked materials (if it doesn't have <code>material.json</code> but each material inside of it does)</li> </ol> <p>Multiple inputs can be specified at the same time. By default, materials will be packed into current working directory, but <code>--output</code> can be used to specify a different output directory.</p> <p>Example usage</p> <pre><code>lazurite pack Actor/ folderWithMaterials/ RenderChunk/material.json -o outputFolder/\n</code></pre> <p>This command will pack <code>Actor</code> and <code>RenderChunk</code> materials as well as all materials from <code>folderWithMaterials/</code> into the <code>outputFolder/</code>.</p>"},{"location":"commands/#label","title":"label","text":"<pre><code>lazurite label [MATERIALS ...] [-o OUTPUT]\n</code></pre> Argument Description Default <code>-o</code> <code>--output</code> Output folder, where labeled material bin files will be stored current directory <p>Adds a comment with debug information at the top of shader programs. It's added to every plain text shader (ESSL, GLSL, Metal) inside of <code>material.bin</code> file. Here is an example of what it looks like:</p> <pre><code>// Shader Information:\n// - Name: RenderChunk\n// - Pass: Transparent\n// - Platform: ESSL_310\n// - Stage: Fragment\n// - Variant: 0\n// - Variant Supported: True\n// - Variant Flags:\n//    - Instancing: On\n//    - RenderAsBillboards: On\n//    - Seasons: Off\n</code></pre> <p>This information can be useful when using graphics debugger such as RenderDoc. As an input, you can specify multiple <code>material.bin</code> files or folders with them. <code>--output</code> can be used to specify output folder where labeled <code>material.bin</code> files will be stored (by default, it's the current working directory).</p> <p>Example usage</p> <pre><code>lazurite label RenderChunk.material.bin folderWithMaterials/ -o outputFolder/\n</code></pre> <p>This command will label <code>RenderChunk.material.bin</code> and all materials from <code>folderWithMaterials/</code> and save them as <code>material.bin</code> files in the <code>outputFolder/</code>.</p>"},{"location":"commands/#clear","title":"clear","text":"<pre><code>lazurite clear [MATERIALS ...] [-o OUTPUT]\n</code></pre> Argument Description Default <code>-o</code> <code>--output</code> Output folder, where cleared material bin files will be stored current directory <p>Wipes all compiled shaders, while removing encryption. This command can be useful when you need a light-weight merge source or when you want to compile RTX shader that shouldn't be encrypted. Note that if you unpack resulting material, its compiled shader files will be empty.</p> <p>Example usage</p> <pre><code>lazurite clear RTXStub.material.bin -o outputFolder/\n</code></pre>"},{"location":"commands/#convert","title":"convert","text":"<pre><code>lazurite convert [MATERIALS ...] [-v VERSION] [-o OUTPUT]\n</code></pre> Argument Description Default <code>-v</code> <code>--version</code> Version number to convert to. See supported versions latest available version <code>-o</code> <code>--output</code> Output folder, where converted material bin files will be stored current directory <p>Converts between <code>.material.bin</code> file formats. Note that it doesn't account for differences in shader logic and converted materials are not guaranteed to be functional. Do not rely on this command to support multiple versions if you are a shader developer, it is always better to directly compile different versions of the shader using vanilla materials from the appropriate game versions as merge source, rather than converting compiled materials after the fact.</p> <p>Example usage</p> <pre><code>lazurite convert RenderChunk.material.bin folderWithMaterials/ -v 22 -o outputFolder/\n</code></pre>"},{"location":"commands/#restore","title":"restore","text":"<pre><code>lazurite restore [MATERIALS ...] [--timeout SECONDS] [--max-workers WORKERS] [--no-processing] [--merge-stages] [--split-passes] [-o OUTPUT]\n</code></pre> Argument Description Default <code>-o</code> <code>--output</code> Output folder, where restored shaders will be stored current directory <code>--max-workers</code> Maximum number of processes to use CPU cores <code>--timeout</code> Maximum time allowed for slow search algorithm, in seconds 10 <code>--merge-stages</code> Generates shader stages in a single file <code>--split-passes</code> Generates separate files for individual passes <code>--no-processing</code> Disable additional processing used for converting from GLSL to BGFX SC <p>Warning</p> <p>This command won't restore shaders from encrypted materials (RTXStub)</p> <p>Restoring latest Android materials</p> <p>Starting from 1.21.31.05 release and 1.21.20.24 preview, restore command can no longer restore source code from Android materials since it's no longer shipped in material.bin files in a readable form. Instead, you can get it from older game versions by restoring their respective material.bin files or by downloading already restored code from mcbe codebase repository</p> <p>Attempts to restore GLSL or BGFX SC source code from ESSL_300 or ESSL_310 materials (mainly used in Android) and varying.def.sc from any materials. It works by identifying the differences between individual shader variants and trying to find matching macro conditionals.</p> <p>This command supports multiprocessing (utilizes multiple CPU cores) for faster restoring times and <code>--max-workers</code> argument can be used to specify max number of processes that will be created. Each process restores its own material.</p> <p>When restoring macro conditionals, lazurite will first try to utilize fast algorithm, and if that fails, it will display <code>slow search</code> message in the console and try the slow search algorithm (brute-force), which has a time limit that can be set with <code>--timeout</code>. If slow search fails to find the conditional in provided time, it will display a <code>not found</code> message in the console and instead will use the best approximate solution it could find, which looks like this in code:</p> <pre><code>// Approximation, matches 256 cases out of 320\n#if defined(ALPHA_TEST_PASS) || (defined(OPAQUE_PASS) &amp;&amp; defined(UI_ENTITY__DISABLED))\n</code></pre> <p>When restoring BGFX SC source code, lazurite will also add <code>// Attention!</code> comment next to code that needs special attention, as it can't be edited automatically. It hints at a potential matrix multiplication or matrix element access.</p> <p>For example:</p> <pre><code>vec4 jitterVertexPosition(vec3 worldPosition) {\n    mat4 offsetProj = Proj;\n    offsetProj[2][0] += SubPixelOffset.x; // Attention!\n    offsetProj[2][1] -= SubPixelOffset.y; // Attention!\n    return ((offsetProj) * (((View) * (vec4(worldPosition, 1.0f))))); // Attention!\n}\n</code></pre> <p>Above code would have to be edited manually to look like this:</p> <pre><code>vec4 jitterVertexPosition(vec3 worldPosition) {\n    mat4 offsetProj = Proj;\n    #if BGFX_SHADER_LANGUAGE_GLSL\n    offsetProj[2][0] += SubPixelOffset.x;\n    offsetProj[2][1] -= SubPixelOffset.y;\n    #else\n    offsetProj[0][2] += SubPixelOffset.x;\n    offsetProj[1][2] -= SubPixelOffset.y;\n    #endif\n    return mul(offsetProj, mul(View, vec4(worldPosition, 1.0f)));\n}\n</code></pre> <p>However keep in mind that <code>mul()</code> can't be used for vector component-wise multiplication, and <code>[x][y]</code> syntax might also refer to accessing vector component of an array element instead of matrix element, in which case there is no need to change the index order.</p> <p>Example usage</p> <pre><code>lazurite restore RenderChunk.material.bin folderWithMaterials/\n</code></pre> <p>This command will restore BGFX SC for <code>RenderChunk.material.bin</code> and for all materials from <code>folderWithMaterials/</code> and save them in the current working directory.</p>"},{"location":"commands/#build","title":"build","text":"<pre><code>lazurite build [PROJECTS ...] [--max-workers WORKERS] [--dxc DXC] [--shaderc SHADERC] [--dxc-args [ARGS ...]] [--shaderc-args [ARGS ...]] [-p [PROFILES ...]] [-d [DEFINES ...]] [-m [MATERIALS ...]] [-e [EXCLUDE ...]] [-o OUTPUT]\n</code></pre> Argument Description Default <code>-o</code> <code>--output</code> Output folder, where compiled materials will be stored project directory <code>--max-workers</code> Maximum number of threads (compiler instances) to use CPU cores times 5 <code>--dxc</code> DXC compiler command Tries to execute <code>dxc</code> first, then <code>./dxc</code> <code>--dxc-args</code> DXC arguments <code>--shaderc</code> SHADERC compiler command Tries to execute <code>shaderc</code> first, then <code>./shaderc</code> <code>--shaderc-args</code> SHADERC arguments <code>-p</code> <code>--profile</code> List of profiles (e.g. <code>-p debug, windows, preview</code>) <code>-d</code> <code>--defines</code> List of defines (e.g. <code>-d DEBUG, \"SAMPLES 10\"</code>) <code>-m</code> <code>--materials</code> List of glob file path patterns that will be compiled as materials when building a project (overwrites <code>include_patterns</code> and <code>exclude_patterns</code>) <code>-e</code> <code>--exclude</code> List of glob file path patterns that will be excluded during project compilation (works with <code>--materials</code>, addtive with <code>exclude_patterns</code>) <code>--skip-validation</code> Do not attempt to validate GLSL or ESSL shaders <code>--glslang</code> Glslang validator path Tries to execute <code>glslang</code> first, then <code>./glslang</code> <p>Compiles all materials from input project paths into output directory (or into project folders, if <code>--output</code> is not specified). See projects documentation for more details.</p> <p>Example usage</p> <pre><code>lazurite build projects/pathTracer/ -p windows, android, preview -o output/\n</code></pre> <p>This command will compile project in <code>projects/pathTracer/</code> folder, with <code>windows</code>, <code>android</code> and <code>preview</code> active profiles and save the compiled materials in the <code>output/</code> folder</p> <p>Download DXC and SHADERC compilers</p> <p>Shaderc is a cross-platform BGFX shader compiler, commonly used for compiling regular, non-rtx shaders.</p> <p>Recommended download: https://github.com/veka0/bgfx-mcbe/releases/tag/binaries</p> <p>Original download source (binaries are no longer available) https://github.com/ddf8196/bgfx-mcbe/actions</p> <p>DXC compiler is mainly used for compiling RTX shaders, as it only supports Direct3D.</p> <p>Download: https://github.com/microsoft/DirectXShaderCompiler/releases</p> Running DXC on Linux <p>When trying to compile materials with DXC compiler on Linux you might encounter the following error:</p> <pre><code>./dxc error while loading shared libraries: libdxcompiler.so: cannot open shared object file: No such file or directory\n</code></pre> <p>It can be solved by prefixing lazurite command with <code>LD_LIBRARY_PATH=&lt;path to folder with libdxcompiler.so&gt;</code></p> <p>For example:</p> <pre><code>LD_LIBRARY_PATH=libs lazurite build myAwesomeShader/\n</code></pre> Running SHADERC on Android (Termux) <p>If you wish to compile on Android, you have to copy shaderc into your termux home directory</p> <pre><code>cp path/to/shaderc ~/new/path/to/shaderc\n</code></pre> <p>Make it executable</p> <pre><code>chmod +x ~/new/path/to/shaderc\n</code></pre> <p>And reference it in future lazurite build commands</p> <pre><code>lazurite build --shaderc ~/new/path/to/shaderc myAwesomeShader/\n</code></pre> <p>You might also encounter the following error:</p> <pre><code>CANNOT LINK EXECUTABLE \"/data/data/com.termux/files/home/shaderc\": library \"libc++_shared.so\" not found: needed by main executable\n</code></pre> <p>Which can be solved by copying required file into your home directory</p> <pre><code>cp $PREFIX/lib/libc++_shared.so ~/\n</code></pre> <p>And referencing directory with your lib file in the lazurite command, by prefixing it with <code>LD_LIBRARY_PATH=&lt;path to folder with libc++_shared.so&gt;</code></p> <p>For example:</p> <pre><code>LD_LIBRARY_PATH=~/ lazurite build --shaderc ~/new/path/to/shaderc myAwesomeShader/\n</code></pre>"},{"location":"commands/#info","title":"info","text":"<pre><code>lazurite info [MATERIALS ...]\n</code></pre> <p>Shows useful information about input material(s).</p> <p>Example output:</p> <pre><code>#### ActorBannerForwardPBR.material.bin ####\nName: ActorBannerForwardPBR\nFormat Version: 22\nEncryption: NONE\nParent: ActorForwardPBR\nTotal Shaders: 544\nPlatforms (4):\n  - Direct3D_SM40\n  - Direct3D_SM50\n  - Direct3D_SM60\n  - Direct3D_SM65\nStages (2):\n  - Fragment\n  - Vertex\nPasses:\n  - DepthOnly: DEPTH_ONLY_PASS\n  - DepthOnlyOpaque: DEPTH_ONLY_OPAQUE_PASS\n  - ForwardPBRAlphaTest: FORWARD_PBR_ALPHA_TEST_PASS\n  - ForwardPBROpaque: FORWARD_PBR_OPAQUE_PASS\n  - ForwardPBRTransparent: FORWARD_PBR_TRANSPARENT_PASS\nFlags:\n  - Change_Color:\n    - Multi: CHANGE_COLOR__MULTI\n    - Off: CHANGE_COLOR__OFF\n  - Emissive:\n    - Off: EMISSIVE__OFF\n  - Fancy:\n    - On: FANCY__ON\n  - Instancing:\n    - Off: INSTANCING__OFF\n    - On: INSTANCING__ON\n  - MaskedMultitexture:\n    - Off: MASKED_MULTITEXTURE__OFF\n    - On: MASKED_MULTITEXTURE__ON\n  - Tinting:\n    - Disabled: TINTING__DISABLED\n    - Enabled: TINTING__ENABLED\nBuffers:\n  - lowp texture2D BrdfLUT:\n    - Reg1: 0\n    - Reg2: 0\n    - Unordered Access: False\n    - Texture Path:\n    - Sampler State:\n      - Texture Filter: Bilinear\n      - Texture Wrap: Clamp\n    - Custom Type Info:\n  - lowp structBuffer DirectionalLightSources:\n    - Reg1: 1\n    - Reg2: 1\n    - Unordered Access: True\n    - Texture Path:\n    - Sampler State:\n    - Custom Type Info:\n      - Struct: LightSourceWorldInfo\n      - Size: 448\n  - lowp texture2D HDRI:\n    - Reg1: 2\n    - Reg2: 2\n    - Unordered Access: False\n    - Texture Path: textures/hdri\n    - Sampler State:\n    - Custom Type Info:\n  - lowp texture2D MaxFrameLuminance r32f:\n    - Reg1: 3\n    - Reg2: 3\n    - Unordered Access: True\n    - Texture Path:\n    - Sampler State:\n    - Custom Type Info:\nUniforms (6):\n  - vec4 AtmosphericScattering = [0.0, 0.0, 0.0, 0.0]\n  - vec4 AtmosphericScatteringToggles = [0.0, 0.0, 0.0, 0.0]\n  - vec4 BannerColors[7]\n  - vec4 BannerUVOffsetsAndScales[7]\n  - vec4 BlockBaseAmbientLightColorIntensity\n  - mat4 Bones[8]\n  - vec4 MyAwesomeUniform\nUniform Overrides (1):\n  - MyAwesomeUniform: BUILTIN_MinecraftCameraPosition\n</code></pre>"},{"location":"commands/#serialize","title":"serialize","text":"<pre><code>lazurite serialize [MATERIALS ...] [-o OUTPUT]\n</code></pre> Argument Description Default <code>-o</code> <code>--output</code> Output folder, where generated <code>.material.json</code> files will be stored current directory <p>Converts input material bin files into minimal json files, one file per material. Those files can be used as a merge source for build command, when compiling a project.</p> <p>Generated json files only contain information that is necessary for compilation and nothing else, so they are quite lightweight. All material properties are sorted alphabetically which makes generated files invariant to changes in property sorting that occasionally occur with game updates. Sorting and small size makes this file format perfect for storing material merge source in version control systems such as GitHub.</p> <p>Example usage</p> <pre><code>lazurite serialize RenderChunk.material.bin folderWithMaterials/ -o outputFolder/\n</code></pre> <p>This command will generate json files for <code>RenderChunk.material.bin</code> and all materials from <code>folderWithMaterials/</code> and save them in the <code>outputFolder/</code>.</p>"},{"location":"guide/","title":"Getting Started","text":"<p>This guide will walk you through the process of creating your first shader with lazurite, step by step. We will be creating a simple terrain shader, that modifies RenderChunk material.</p>"},{"location":"guide/#requirements","title":"Requirements","text":"<p>First, you need to install lazurite (see installation instructions). We will also need shaderc compiler executable, in order to compile shaders from source code. See build command for download links.</p> <p>Some general shader theory and BGFX shader compiler knowledge would also help.</p> <p>BGFX</p> <p>BGFX is the cross platform graphics library that RenderDragon is built on top of.</p>"},{"location":"guide/#creating-a-new-project","title":"Creating a new project","text":"<p>First, let's create a new project. Make a new folder. In this guide we will call it <code>helloWorld</code>. Add <code>project.json</code> file into it (leave it empty for now), and make a new <code>RenderChunk</code> folder inside of <code>helloWorld</code>. This folder represents a RenderChunk material (RenderChunk.material.bin) that we will be modifying. Then add <code>shaders</code> folder inside of <code>RenderChunk</code>, this is where shader source code will go. Also add a <code>vanilla</code> folder, next to your project folder and copy your vanilla <code>RenderChunk.material.bin</code> file into it.</p> <p>Resulting directory tree should look like this:</p> <pre><code>helloWorld/\n\u251c\u2500\u2500 RenderChunk/\n\u2502   \u2514\u2500\u2500 shaders/\n\u2514\u2500\u2500 project.json\nvanilla/\n\u2514\u2500\u2500 RenderChunk.material.bin\n</code></pre>"},{"location":"guide/#obtaining-source-code","title":"Obtaining source code","text":"<p>Next step would be to get the source code. This guide will show you how to obtain it by yourself.</p> <p>Restoring latest Android materials</p> <p>Starting from 1.21.31.05 release and 1.21.20.24 preview, restore command can no longer restore source code from Android materials since it's no longer shipped in material.bin files in a readable form. Instead, you can get it from older game versions by restoring their respective material.bin files or by downloading already restored code from mcbe codebase repository</p> <p>Lazurite has a restore command that can partially recover source code from Android materials* (only for older versions; see above warning). You can use it on RenderChunk.material.bin file that you copied from your Android game installation:</p> <pre><code>lazurite restore RenderChunk.material.bin\n</code></pre> <p>Which should generate 3 files:</p> <pre><code>RenderChunk.ESSL_310.Fragment.sc\nRenderChunk.ESSL_310.Vertex.sc\nRenderChunk.varying.def.sc\n</code></pre> <p>Or you can also get the results of a <code>restore</code> command from this repository: https://github.com/veka0/mcbe-shader-codebase/tree/main/materials/RenderChunk</p> <p>You also need a bgfx_shader.sh file</p> <p>Copy those files into <code>shaders/</code> directory in RenderChunk and rename them, to get the following directory tree:</p> <pre><code>helloWorld/\n\u251c\u2500\u2500 RenderChunk/\n\u2502   \u2514\u2500\u2500 shaders/\n\u2502       \u251c\u2500\u2500 bgfx_shader.sh\n\u2502       \u251c\u2500\u2500 fragment.sc\n\u2502       \u251c\u2500\u2500 vertex.sc\n\u2502       \u2514\u2500\u2500 varying.def.sc\n\u2514\u2500\u2500 project.json\nvanilla/\n\u2514\u2500\u2500 RenderChunk.material.bin\n</code></pre>"},{"location":"guide/#formatting","title":"Formatting","text":"<p>Source code, generated with restore command is not immediately compilable and requires manual editing to make it work. We will be doing the bare minimum editing that's required to compile RenderChunk shaders.</p>"},{"location":"guide/#vertexsc","title":"vertex.sc","text":"<p>Let's start by editing vertex.sc.</p> <p>First, add the <code>#include \"bgfx_shader.sh\"</code> line at the beginning of the file, but after <code>$input</code> and <code>$output</code> directives. This is a necessary step for all BGFX shaders and it should look something like this:</p> <pre><code>$input a_color0, a_position, a_texcoord0, a_texcoord1\n#ifdef INSTANCING__ON\n$input i_data1, i_data2, i_data3\n#endif\n$output v_color0, v_fog, v_lightmapUV, v_texcoord0, v_worldPos\n\n#include \"bgfx_shader.sh\"\n</code></pre> <p>Then remove the following code at the start of the file. It's not needed since <code>instMul</code> functions are added from <code>bgfx_shader.sh</code></p> <pre><code>#ifdef INSTANCING__ON\nvec3 instMul(vec3 _vec, mat3 _mtx) {\n    return ((_vec) * (_mtx)); // Attention!\n}\nvec3 instMul(mat3 _mtx, vec3 _vec) {\n    return ((_mtx) * (_vec)); // Attention!\n}\nvec4 instMul(vec4 _vec, mat4 _mtx) {\n    return ((_vec) * (_mtx)); // Attention!\n}\nvec4 instMul(mat4 _mtx, vec4 _vec) {\n    return ((_mtx) * (_vec)); // Attention!\n}\n#endif\n</code></pre> <p>Next, we need to go through the code marked with <code>// Attention!</code> comment. Lazurite marks lines of code in this way, if they may contain matrix multiplication or matrix element access.</p> <p>By convention, multiplying matrices by other matrices or vectors in BGFX shaders has to be done with a <code>mul()</code> function. In addition, GLSL uses a different matrix row-column order in comparison to other APIs, so we need to switch row and column indices when shader is compiled for APIs other than GLSL.</p> <p>Edit the following function:</p> <pre><code>vec4 jitterVertexPosition(vec3 worldPosition) {\n    mat4 offsetProj = Proj;\n    offsetProj[2][0] += SubPixelOffset.x; // Attention!\n    offsetProj[2][1] -= SubPixelOffset.y; // Attention!\n    return ((offsetProj) * (((View) * (vec4(worldPosition, 1.0f))))); // Attention!\n}\n</code></pre> <p>Into this:</p> <pre><code>vec4 jitterVertexPosition(vec3 worldPosition) {\n    mat4 offsetProj = Proj;\n    #if BGFX_SHADER_LANGUAGE_GLSL\n    offsetProj[2][0] += SubPixelOffset.x;\n    offsetProj[2][1] -= SubPixelOffset.y;\n    #else\n    offsetProj[0][2] += SubPixelOffset.x;\n    offsetProj[1][2] -= SubPixelOffset.y;\n    #endif\n    return mul(offsetProj, mul(View, vec4(worldPosition, 1.0f)));\n}\n</code></pre> <p>In this function:</p> <pre><code>void transformAsBillboardVertex(inout StandardVertexInput stdInput, inout VertexOutput vertOutput) {\n    stdInput.worldPos += vec3(0.5, 0.5, 0.5);\n    vec3 forward = normalize(stdInput.worldPos - ViewPositionAndTime.xyz);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 offsets = stdInput.vertInput.color0.xyz;\n    stdInput.worldPos -= up * (offsets.z - 0.5) + right * (offsets.x - 0.5);\n    vertOutput.position = ((ViewProj) * (vec4(stdInput.worldPos, 1.0))); // Attention!\n}\n</code></pre> <p>edit the highlighted line into this:</p> <pre><code>vertOutput.position = mul(ViewProj, vec4(stdInput.worldPos, 1.0));\n</code></pre> <p>In this function:</p> <pre><code>void StandardTemplate_VertSharedTransform(inout StandardVertexInput stdInput, inout VertexOutput vertOutput) {\n    VertexInput vertInput = stdInput.vertInput;\n    #ifdef INSTANCING__OFF\n    vec3 wpos = ((World) * (vec4(vertInput.position, 1.0))).xyz; // Attention!\n    #endif\n    #ifdef INSTANCING__ON\n    mat4 model;\n    model[0] = vec4(vertInput.instanceData0.x, vertInput.instanceData1.x, vertInput.instanceData2.x, 0);\n    model[1] = vec4(vertInput.instanceData0.y, vertInput.instanceData1.y, vertInput.instanceData2.y, 0);\n    model[2] = vec4(vertInput.instanceData0.z, vertInput.instanceData1.z, vertInput.instanceData2.z, 0);\n    model[3] = vec4(vertInput.instanceData0.w, vertInput.instanceData1.w, vertInput.instanceData2.w, 1);\n    vec3 wpos = instMul(model, vec4(vertInput.position, 1.0)).xyz;\n    #endif\n    vertOutput.position = ((ViewProj) * (vec4(wpos, 1.0))); // Attention!\n    stdInput.worldPos = wpos;\n    vertOutput.worldPos = wpos;\n}\n</code></pre> <p>edit the 2 highlighted lines into this:</p> <pre><code>vec3 wpos = mul(World, vec4(vertInput.position, 1.0)).xyz;\n</code></pre> <pre><code>vertOutput.position = mul(ViewProj, vec4(wpos, 1.0));\n</code></pre> <p>And this is it! <code>vertex.sc</code> can now be compiled correctly.</p>"},{"location":"guide/#fragmentsc","title":"fragment.sc","text":"<p>Next, let's edit fragment shader code. Similar to vertex shader, start by adding <code>#include \"bgfx_shader.sh\"</code> line at the beginning after <code>$input</code> directives, which should look like this:</p> <pre><code>$input v_color0, v_fog, v_lightmapUV, v_texcoord0, v_worldPos\n\n#include \"bgfx_shader.sh\"\n</code></pre> <p>Now we need to modify texture sampling methods to use the correct cross-platform BGFX functions, which requires changing the following code:</p> <pre><code>vec4 textureSample(mediump sampler2D _sampler, vec2 _coord) {\n    return texture(_sampler, _coord);\n}\nvec4 textureSample(mediump sampler3D _sampler, vec3 _coord) {\n    return texture(_sampler, _coord);\n}\nvec4 textureSample(mediump samplerCube _sampler, vec3 _coord) {\n    return texture(_sampler, _coord);\n}\nvec4 textureSample(mediump sampler2D _sampler, vec2 _coord, float _lod) {\n    return textureLod(_sampler, _coord, _lod);\n}\nvec4 textureSample(mediump sampler3D _sampler, vec3 _coord, float _lod) {\n    return textureLod(_sampler, _coord, _lod);\n}\nvec4 textureSample(mediump sampler2DArray _sampler, vec3 _coord) {\n    return texture(_sampler, _coord);\n}\nvec4 textureSample(mediump sampler2DArray _sampler, vec3 _coord, float _lod) {\n    return textureLod(_sampler, _coord, _lod);\n}\n</code></pre> <p>Into this:</p> <pre><code>vec4 textureSample(mediump sampler2D _sampler, vec2 _coord) {\n    return texture2D(_sampler, _coord);\n}\nvec4 textureSample(mediump sampler3D _sampler, vec3 _coord) {\n    return texture3D(_sampler, _coord);\n}\nvec4 textureSample(mediump samplerCube _sampler, vec3 _coord) {\n    return textureCube(_sampler, _coord);\n}\nvec4 textureSample(mediump sampler2D _sampler, vec2 _coord, float _lod) {\n    return texture2DLod(_sampler, _coord, _lod);\n}\nvec4 textureSample(mediump sampler3D _sampler, vec3 _coord, float _lod) {\n    return texture3DLod(_sampler, _coord, _lod);\n}\nvec4 textureSample(mediump sampler2DArray _sampler, vec3 _coord) {\n    return texture2DArray(_sampler, _coord);\n}\nvec4 textureSample(mediump sampler2DArray _sampler, vec3 _coord, float _lod) {\n    return texture2DArrayLod(_sampler, _coord, _lod);\n}\n</code></pre> <p>Then remove the following code, since it's already included in <code>bgfx_shader.sh</code>:</p> <pre><code>#if defined(SEASONS__ON)&amp;&amp;(defined(ALPHA_TEST_PASS)|| defined(OPAQUE_PASS))\nvec3 vec3_splat(float _x) {\n    return vec3(_x, _x, _x);\n}\n#endif\n</code></pre> <p>Finally, we need to edit the following function:</p> <pre><code>void StandardTemplate_Opaque_Frag(FragmentInput fragInput, inout FragmentOutput fragOutput) {\n    StandardSurfaceInput surfaceInput = StandardTemplate_DefaultInput(fragInput);\n    StandardSurfaceOutput surfaceOutput = StandardTemplate_DefaultOutput();\n    surfaceInput.UV = fragInput.texcoord0;\n    surfaceInput.Color = fragInput.color0.xyz;\n    surfaceInput.Alpha = fragInput.color0.a;\n    #if defined(ALPHA_TEST_PASS)|| defined(DEPTH_ONLY_PASS)\n    RenderChunkSurfAlpha(surfaceInput, surfaceOutput);\n    #endif\n    #if defined(DEPTH_ONLY_OPAQUE_PASS)|| defined(OPAQUE_PASS)\n    RenderChunkSurfOpaque(surfaceInput, surfaceOutput);\n    #endif\n    #ifdef TRANSPARENT_PASS\n    RenderChunkSurfTransparent(surfaceInput, surfaceOutput);\n    #endif\n    StandardTemplate_CustomSurfaceShaderEntryIdentity(surfaceInput.UV, fragInput.worldPos, surfaceOutput);\n    DirectionalLight primaryLight;\n    vec3 worldLightDirection = LightWorldSpaceDirection.xyz;\n    primaryLight.ViewSpaceDirection = ((View) * (vec4(worldLightDirection, 0))).xyz; // Attention!\n    primaryLight.Intensity = LightDiffuseColorAndIlluminance.rgb * LightDiffuseColorAndIlluminance.w;\n    CompositingOutput compositingOutput;\n    compositingOutput.mLitColor = computeLighting_RenderChunk(fragInput, surfaceInput, surfaceOutput, primaryLight);\n    fragOutput.Color0 = standardComposite(surfaceOutput, compositingOutput);\n    RenderChunkApplyFog(fragInput, surfaceInput, surfaceOutput, fragOutput);\n}\n</code></pre> <p>by changing highlighted line into this:</p> <pre><code>primaryLight.ViewSpaceDirection = mul(View, vec4(worldLightDirection, 0)).xyz;\n</code></pre> <p>And we're done! Both fragment and vertex shaders are now compilable. <code>varying.def.sc</code> doesn't require any editing in this guide.</p> <p>Below you can find the edited files (which were also additionally cleaned up, for better code readability):</p> fragment.sc fragment.sc<pre><code>/*\n* Available Macros:\n*\n* Passes:\n* - ALPHA_TEST_PASS\n* - DEPTH_ONLY_PASS\n* - DEPTH_ONLY_OPAQUE_PASS\n* - OPAQUE_PASS\n* - TRANSPARENT_PASS\n*\n* Instancing:\n* - INSTANCING__OFF (not used)\n* - INSTANCING__ON\n*\n* RenderAsBillboards:\n* - RENDER_AS_BILLBOARDS__OFF (not used)\n* - RENDER_AS_BILLBOARDS__ON (not used)\n*\n* Seasons:\n* - SEASONS__OFF\n* - SEASONS__ON\n*/\n\n$input v_color0, v_fog, v_lightmapUV, v_texcoord0, v_worldPos\n\n#include \"bgfx_shader.sh\"\n\nvec4 textureSample(mediump sampler2D _sampler, vec2 _coord) {\n    return texture2D(_sampler, _coord);\n}\nvec4 textureSample(mediump sampler3D _sampler, vec3 _coord) {\n    return texture3D(_sampler, _coord);\n}\nvec4 textureSample(mediump samplerCube _sampler, vec3 _coord) {\n    return textureCube(_sampler, _coord);\n}\nvec4 textureSample(mediump sampler2D _sampler, vec2 _coord, float _lod) {\n    return texture2DLod(_sampler, _coord, _lod);\n}\nvec4 textureSample(mediump sampler3D _sampler, vec3 _coord, float _lod) {\n    return texture3DLod(_sampler, _coord, _lod);\n}\nvec4 textureSample(mediump sampler2DArray _sampler, vec3 _coord) {\n    return texture2DArray(_sampler, _coord);\n}\nvec4 textureSample(mediump sampler2DArray _sampler, vec3 _coord, float _lod) {\n    return texture2DArrayLod(_sampler, _coord, _lod);\n}\n\nuniform vec4 FogAndDistanceControl;\nuniform vec4 FogColor;\nuniform vec4 GlobalRoughness;\nuniform vec4 LightDiffuseColorAndIlluminance;\nuniform vec4 LightWorldSpaceDirection;\nuniform vec4 MaterialID;\nuniform vec4 RenderChunkFogAlpha;\nuniform vec4 SubPixelOffset;\nuniform vec4 ViewPositionAndTime;\nvec4 ViewRect;\nmat4 Proj;\nmat4 View;\nvec4 ViewTexel;\nmat4 InvView;\nmat4 InvProj;\nmat4 ViewProj;\nmat4 InvViewProj;\nmat4 PrevViewProj;\nmat4 WorldArray[4];\nmat4 World;\nmat4 WorldView;\nmat4 WorldViewProj;\nvec4 PrevWorldPosOffset;\nvec4 AlphaRef4;\nfloat AlphaRef;\n\nstruct FragmentInput {\n    vec4 color0;\n    vec4 fog;\n    vec2 lightmapUV;\n    vec2 texcoord0;\n    vec3 worldPos;\n};\n\nstruct FragmentOutput {\n    vec4 Color0;\n};\n\nSAMPLER2D_AUTOREG(s_LightMapTexture);\nSAMPLER2D_AUTOREG(s_MatTexture);\nSAMPLER2D_AUTOREG(s_SeasonsTexture);\nstruct StandardSurfaceInput {\n    vec2 UV;\n    vec3 Color;\n    float Alpha;\n    vec2 lightmapUV;\n    vec4 fog;\n    vec2 texcoord0;\n};\n\nStandardSurfaceInput StandardTemplate_DefaultInput(FragmentInput fragInput) {\n    StandardSurfaceInput result;\n    result.UV = vec2(0, 0);\n    result.Color = vec3(1, 1, 1);\n    result.Alpha = 1.0;\n    result.lightmapUV = fragInput.lightmapUV;\n    result.fog = fragInput.fog;\n    result.texcoord0 = fragInput.texcoord0;\n    return result;\n}\nstruct StandardSurfaceOutput {\n    vec3 Albedo;\n    float Alpha;\n    float Metallic;\n    float Roughness;\n    float Occlusion;\n    float Emissive;\n    float Subsurface;\n    vec3 AmbientLight;\n    vec3 ViewSpaceNormal;\n};\n\nStandardSurfaceOutput StandardTemplate_DefaultOutput() {\n    StandardSurfaceOutput result;\n    result.Albedo = vec3(1, 1, 1);\n    result.Alpha = 1.0;\n    result.Metallic = 0.0;\n    result.Roughness = 1.0;\n    result.Occlusion = 0.0;\n    result.Emissive = 0.0;\n    result.Subsurface = 0.0;\n    result.AmbientLight = vec3(0.0, 0.0, 0.0);\n    result.ViewSpaceNormal = vec3(0, 1, 0);\n    return result;\n}\nvec3 applyFogVanilla(vec3 diffuse, vec3 fogColor, float fogIntensity) {\n    return mix(diffuse, fogColor, fogIntensity);\n}\nvec4 applySeasons(vec3 vertexColor, float vertexAlpha, vec4 diffuse) {\n    vec2 uv = vertexColor.xy;\n    diffuse.rgb *= mix(vec3(1.0, 1.0, 1.0), textureSample(s_SeasonsTexture, uv).rgb * 2.0, vertexColor.b);\n    diffuse.rgb *= vec3_splat(vertexAlpha);\n    diffuse.a = 1.0;\n    return diffuse;\n}\nvoid RenderChunkApplyFog(FragmentInput fragInput, StandardSurfaceInput surfaceInput, StandardSurfaceOutput surfaceOutput, inout FragmentOutput fragOutput) {\n    fragOutput.Color0.rgb = applyFogVanilla(fragOutput.Color0.rgb, FogColor.rgb, surfaceInput.fog.a);\n}\nvoid RenderChunkSurfTransparent(in StandardSurfaceInput surfaceInput, inout StandardSurfaceOutput surfaceOutput) {\n    vec4 diffuse = textureSample(s_MatTexture, surfaceInput.UV);\n    diffuse.a *= surfaceInput.Alpha;\n    diffuse.rgb *= surfaceInput.Color.rgb;\n    surfaceOutput.Albedo = diffuse.rgb;\n    surfaceOutput.Alpha = diffuse.a;\n    surfaceOutput.Roughness = GlobalRoughness.x;\n}\nstruct CompositingOutput {\n    vec3 mLitColor;\n};\n\nvec4 standardComposite(StandardSurfaceOutput stdOutput, CompositingOutput compositingOutput) {\n    return vec4(compositingOutput.mLitColor, stdOutput.Alpha);\n}\nvoid StandardTemplate_CustomSurfaceShaderEntryIdentity(vec2 uv, vec3 worldPosition, inout StandardSurfaceOutput surfaceOutput) {\n}\nstruct DirectionalLight {\n    vec3 ViewSpaceDirection;\n    vec3 Intensity;\n};\n\nvec3 computeLighting_RenderChunk(FragmentInput fragInput, StandardSurfaceInput stdInput, StandardSurfaceOutput stdOutput, DirectionalLight primaryLight) {\n    return textureSample(s_LightMapTexture, stdInput.lightmapUV).rgb * stdOutput.Albedo;\n}\nvoid RenderChunkSurfAlpha(in StandardSurfaceInput surfaceInput, inout StandardSurfaceOutput surfaceOutput) {\n    vec4 diffuse = textureSample(s_MatTexture, surfaceInput.UV);\n    const float ALPHA_THRESHOLD = 0.5;\n    if (diffuse.a &lt; ALPHA_THRESHOLD) {\n        discard;\n    }\n    #ifdef ALPHA_TEST_PASS\n    #ifdef SEASONS__ON\n    diffuse = applySeasons(surfaceInput.Color, surfaceInput.Alpha, diffuse);\n    #else\n    diffuse.rgb *= surfaceInput.Color.rgb;\n    #endif\n    surfaceOutput.Albedo = diffuse.rgb;\n    surfaceOutput.Alpha = diffuse.a;\n    surfaceOutput.Roughness = GlobalRoughness.x;\n    #endif\n}\nvoid RenderChunkSurfOpaque(in StandardSurfaceInput surfaceInput, inout StandardSurfaceOutput surfaceOutput) {\n    #ifdef OPAQUE_PASS\n    vec4 diffuse = textureSample(s_MatTexture, surfaceInput.UV);\n\n    #ifdef SEASONS__ON\n    diffuse = applySeasons(surfaceInput.Color, surfaceInput.Alpha, diffuse);\n    #else\n    diffuse.rgb *= surfaceInput.Color.rgb;\n    diffuse.a = surfaceInput.Alpha;\n    #endif\n\n    surfaceOutput.Albedo = diffuse.rgb;\n    surfaceOutput.Alpha = diffuse.a;\n    surfaceOutput.Roughness = GlobalRoughness.x;\n    #endif\n}\nvoid StandardTemplate_Opaque_Frag(FragmentInput fragInput, inout FragmentOutput fragOutput) {\n    StandardSurfaceInput surfaceInput = StandardTemplate_DefaultInput(fragInput);\n    StandardSurfaceOutput surfaceOutput = StandardTemplate_DefaultOutput();\n    surfaceInput.UV = fragInput.texcoord0;\n    surfaceInput.Color = fragInput.color0.xyz;\n    surfaceInput.Alpha = fragInput.color0.a;\n    #ifdef TRANSPARENT_PASS\n    RenderChunkSurfTransparent(surfaceInput, surfaceOutput);\n    #elif defined(ALPHA_TEST_PASS)|| defined(DEPTH_ONLY_PASS)\n    RenderChunkSurfAlpha(surfaceInput, surfaceOutput);\n    #elif defined(DEPTH_ONLY_OPAQUE_PASS)|| defined(OPAQUE_PASS)\n    RenderChunkSurfOpaque(surfaceInput, surfaceOutput);\n    #endif\n    StandardTemplate_CustomSurfaceShaderEntryIdentity(surfaceInput.UV, fragInput.worldPos, surfaceOutput);\n    DirectionalLight primaryLight;\n    vec3 worldLightDirection = LightWorldSpaceDirection.xyz;\n    primaryLight.ViewSpaceDirection = mul(View, vec4(worldLightDirection, 0)).xyz;\n    primaryLight.Intensity = LightDiffuseColorAndIlluminance.rgb * LightDiffuseColorAndIlluminance.w;\n    CompositingOutput compositingOutput;\n    compositingOutput.mLitColor = computeLighting_RenderChunk(fragInput, surfaceInput, surfaceOutput, primaryLight);\n    fragOutput.Color0 = standardComposite(surfaceOutput, compositingOutput);\n    RenderChunkApplyFog(fragInput, surfaceInput, surfaceOutput, fragOutput);\n}\nvoid main() {\n    FragmentInput fragmentInput;\n    FragmentOutput fragmentOutput;\n    fragmentInput.color0 = v_color0;\n    fragmentInput.fog = v_fog;\n    fragmentInput.lightmapUV = v_lightmapUV;\n    fragmentInput.texcoord0 = v_texcoord0;\n    fragmentInput.worldPos = v_worldPos;\n    fragmentOutput.Color0 = vec4(0, 0, 0, 0);\n    ViewRect = u_viewRect;\n    Proj = u_proj;\n    View = u_view;\n    ViewTexel = u_viewTexel;\n    InvView = u_invView;\n    InvProj = u_invProj;\n    ViewProj = u_viewProj;\n    InvViewProj = u_invViewProj;\n    PrevViewProj = u_prevViewProj;\n    {\n        WorldArray[0] = u_model[0];\n        WorldArray[1] = u_model[1];\n        WorldArray[2] = u_model[2];\n        WorldArray[3] = u_model[3];\n    }\n    World = u_model[0];\n    WorldView = u_modelView;\n    WorldViewProj = u_modelViewProj;\n    PrevWorldPosOffset = u_prevWorldPosOffset;\n    AlphaRef4 = u_alphaRef4;\n    AlphaRef = u_alphaRef4.x;\n    StandardTemplate_Opaque_Frag(fragmentInput, fragmentOutput);\n    gl_FragColor = fragmentOutput.Color0;\n}\n</code></pre> vertex.sc vertex.sc<pre><code>/*\n* Available Macros:\n*\n* Passes:\n* - ALPHA_TEST_PASS (not used)\n* - DEPTH_ONLY_PASS (not used)\n* - DEPTH_ONLY_OPAQUE_PASS (not used)\n* - OPAQUE_PASS (not used)\n* - TRANSPARENT_PASS\n*\n* Instancing:\n* - INSTANCING__OFF\n* - INSTANCING__ON\n*\n* RenderAsBillboards:\n* - RENDER_AS_BILLBOARDS__OFF (not used)\n* - RENDER_AS_BILLBOARDS__ON\n*\n* Seasons:\n* - SEASONS__OFF (not used)\n* - SEASONS__ON (not used)\n*/\n\n$input a_color0, a_position, a_texcoord0, a_texcoord1\n#ifdef INSTANCING__ON\n$input i_data1, i_data2, i_data3\n#endif\n\n$output v_color0, v_fog, v_lightmapUV, v_texcoord0, v_worldPos\n\n#include \"bgfx_shader.sh\"\n\nuniform vec4 FogAndDistanceControl;\nuniform vec4 FogColor;\nuniform vec4 GlobalRoughness;\nuniform vec4 LightDiffuseColorAndIlluminance;\nuniform vec4 LightWorldSpaceDirection;\nuniform vec4 MaterialID;\nuniform vec4 RenderChunkFogAlpha;\nuniform vec4 SubPixelOffset;\nuniform vec4 ViewPositionAndTime;\nvec4 ViewRect;\nmat4 Proj;\nmat4 View;\nvec4 ViewTexel;\nmat4 InvView;\nmat4 InvProj;\nmat4 ViewProj;\nmat4 InvViewProj;\nmat4 PrevViewProj;\nmat4 WorldArray[4];\nmat4 World;\nmat4 WorldView;\nmat4 WorldViewProj;\nvec4 PrevWorldPosOffset;\nvec4 AlphaRef4;\nfloat AlphaRef;\n\nstruct VertexInput {\n    vec4 color0;\n    vec2 lightmapUV;\n    vec3 position;\n    vec2 texcoord0;\n    #ifdef INSTANCING__ON\n    vec4 instanceData0;\n    vec4 instanceData1;\n    vec4 instanceData2;\n    #endif\n};\n\nstruct VertexOutput {\n    vec4 position;\n    vec4 color0;\n    vec4 fog;\n    vec2 lightmapUV;\n    vec2 texcoord0;\n    vec3 worldPos;\n};\n\nstruct StandardVertexInput {\n    VertexInput vertInput;\n    vec3 worldPos;\n};\n\nvec4 jitterVertexPosition(vec3 worldPosition) {\n    mat4 offsetProj = Proj;\n    #if BGFX_SHADER_LANGUAGE_GLSL\n    offsetProj[2][0] += SubPixelOffset.x;\n    offsetProj[2][1] -= SubPixelOffset.y;\n    #else\n    offsetProj[0][2] += SubPixelOffset.x;\n    offsetProj[1][2] -= SubPixelOffset.y;\n    #endif\n    return mul(offsetProj, mul(View, vec4(worldPosition, 1.0f)));\n}\nfloat calculateFogIntensityFadedVanilla(float cameraDepth, float maxDistance, float fogStart, float fogEnd, float fogAlpha) {\n    float distance = cameraDepth / maxDistance;\n    distance += fogAlpha;\n    return clamp((distance - fogStart) / (fogEnd - fogStart), 0.0, 1.0);\n}\nvoid transformAsBillboardVertex(inout StandardVertexInput stdInput, inout VertexOutput vertOutput) {\n    stdInput.worldPos += vec3(0.5, 0.5, 0.5);\n    vec3 forward = normalize(stdInput.worldPos - ViewPositionAndTime.xyz);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 offsets = stdInput.vertInput.color0.xyz;\n    stdInput.worldPos -= up * (offsets.z - 0.5) + right * (offsets.x - 0.5);\n    vertOutput.position = mul(ViewProj, vec4(stdInput.worldPos, 1.0));\n}\nfloat RenderChunkVert(StandardVertexInput stdInput, inout VertexOutput vertOutput) {\n    #ifdef RENDER_AS_BILLBOARDS__ON\n    vertOutput.color0 = vec4(1.0, 1.0, 1.0, 1.0);\n    transformAsBillboardVertex(stdInput, vertOutput);\n    #endif\n    float cameraDepth = length(ViewPositionAndTime.xyz - stdInput.worldPos);\n    float fogIntensity = calculateFogIntensityFadedVanilla(cameraDepth, FogAndDistanceControl.z, FogAndDistanceControl.x, FogAndDistanceControl.y, RenderChunkFogAlpha.x);\n    vertOutput.fog = vec4(FogColor.rgb, fogIntensity);\n    vertOutput.position = jitterVertexPosition(stdInput.worldPos);\n    return cameraDepth;\n}\nvoid RenderChunkVertTransparent(StandardVertexInput stdInput, inout VertexOutput vertOutput) {\n    float cameraDepth = RenderChunkVert(stdInput, vertOutput);\n    bool shouldBecomeOpaqueInTheDistance = stdInput.vertInput.color0.a &lt; 0.95;\n    if (shouldBecomeOpaqueInTheDistance) {\n        float cameraDistance = cameraDepth / FogAndDistanceControl.w;\n        float alphaFadeOut = clamp(cameraDistance, 0.0, 1.0);\n        vertOutput.color0.a = mix(stdInput.vertInput.color0.a, 1.0, alphaFadeOut);\n    }\n}\nvoid StandardTemplate_VertSharedTransform(inout StandardVertexInput stdInput, inout VertexOutput vertOutput) {\n    VertexInput vertInput = stdInput.vertInput;\n    #ifdef INSTANCING__ON\n    mat4 model;\n    model[0] = vec4(vertInput.instanceData0.x, vertInput.instanceData1.x, vertInput.instanceData2.x, 0);\n    model[1] = vec4(vertInput.instanceData0.y, vertInput.instanceData1.y, vertInput.instanceData2.y, 0);\n    model[2] = vec4(vertInput.instanceData0.z, vertInput.instanceData1.z, vertInput.instanceData2.z, 0);\n    model[3] = vec4(vertInput.instanceData0.w, vertInput.instanceData1.w, vertInput.instanceData2.w, 1);\n    vec3 wpos = instMul(model, vec4(vertInput.position, 1.0)).xyz;\n    #else\n    vec3 wpos = mul(World, vec4(vertInput.position, 1.0)).xyz;\n    #endif\n    vertOutput.position = mul(ViewProj, vec4(wpos, 1.0));\n    stdInput.worldPos = wpos;\n    vertOutput.worldPos = wpos;\n}\nvoid StandardTemplate_VertexPreprocessIdentity(VertexInput vertInput, inout VertexOutput vertOutput) {\n}\n\nvoid StandardTemplate_InvokeVertexPreprocessFunction(inout VertexInput vertInput, inout VertexOutput vertOutput);\nvoid StandardTemplate_InvokeVertexOverrideFunction(StandardVertexInput vertInput, inout VertexOutput vertOutput);\nvoid StandardTemplate_InvokeLightingVertexFunction(VertexInput vertInput, inout VertexOutput vertOutput, vec3 worldPosition);\n\nvoid computeLighting_RenderChunk_Vertex(VertexInput vInput, inout VertexOutput vOutput, vec3 worldPosition) {\n    vOutput.lightmapUV = vInput.lightmapUV;\n}\nvoid StandardTemplate_VertShared(VertexInput vertInput, inout VertexOutput vertOutput) {\n    StandardTemplate_InvokeVertexPreprocessFunction(vertInput, vertOutput);\n    StandardVertexInput stdInput;\n    stdInput.vertInput = vertInput;\n    StandardTemplate_VertSharedTransform(stdInput, vertOutput);\n    vertOutput.texcoord0 = vertInput.texcoord0;\n    vertOutput.color0 = vertInput.color0;\n    StandardTemplate_InvokeVertexOverrideFunction(stdInput, vertOutput);\n    StandardTemplate_InvokeLightingVertexFunction(vertInput, vertOutput, stdInput.worldPos);\n}\nvoid StandardTemplate_InvokeVertexPreprocessFunction(inout VertexInput vertInput, inout VertexOutput vertOutput) {\n    StandardTemplate_VertexPreprocessIdentity(vertInput, vertOutput);\n}\nvoid StandardTemplate_InvokeVertexOverrideFunction(StandardVertexInput vertInput, inout VertexOutput vertOutput) {\n    #ifdef TRANSPARENT_PASS\n    RenderChunkVertTransparent(vertInput, vertOutput);\n    #else\n    RenderChunkVert(vertInput, vertOutput);\n    #endif\n}\nvoid StandardTemplate_InvokeLightingVertexFunction(VertexInput vertInput, inout VertexOutput vertOutput, vec3 worldPosition) {\n    computeLighting_RenderChunk_Vertex(vertInput, vertOutput, worldPosition);\n}\nvoid StandardTemplate_Opaque_Vert(VertexInput vertInput, inout VertexOutput vertOutput) {\n    StandardTemplate_VertShared(vertInput, vertOutput);\n}\nvoid main() {\n    VertexInput vertexInput;\n    VertexOutput vertexOutput;\n    vertexInput.color0 = (a_color0);\n    vertexInput.lightmapUV = (a_texcoord1);\n    vertexInput.position = (a_position);\n    vertexInput.texcoord0 = (a_texcoord0);\n    #ifdef INSTANCING__ON\n    vertexInput.instanceData0 = i_data1;\n    vertexInput.instanceData1 = i_data2;\n    vertexInput.instanceData2 = i_data3;\n    #endif\n    vertexOutput.color0 = vec4(0, 0, 0, 0);\n    vertexOutput.fog = vec4(0, 0, 0, 0);\n    vertexOutput.lightmapUV = vec2(0, 0);\n    vertexOutput.texcoord0 = vec2(0, 0);\n    vertexOutput.worldPos = vec3(0, 0, 0);\n    vertexOutput.position = vec4(0, 0, 0, 0);\n    ViewRect = u_viewRect;\n    Proj = u_proj;\n    View = u_view;\n    ViewTexel = u_viewTexel;\n    InvView = u_invView;\n    InvProj = u_invProj;\n    ViewProj = u_viewProj;\n    InvViewProj = u_invViewProj;\n    PrevViewProj = u_prevViewProj;\n    {\n        WorldArray[0] = u_model[0];\n        WorldArray[1] = u_model[1];\n        WorldArray[2] = u_model[2];\n        WorldArray[3] = u_model[3];\n    }\n    World = u_model[0];\n    WorldView = u_modelView;\n    WorldViewProj = u_modelViewProj;\n    PrevWorldPosOffset = u_prevWorldPosOffset;\n    AlphaRef4 = u_alphaRef4;\n    AlphaRef = u_alphaRef4.x;\n    StandardTemplate_Opaque_Vert(vertexInput, vertexOutput);\n    v_color0 = vertexOutput.color0;\n    v_fog = vertexOutput.fog;\n    v_lightmapUV = vertexOutput.lightmapUV;\n    v_texcoord0 = vertexOutput.texcoord0;\n    v_worldPos = vertexOutput.worldPos;\n    gl_Position = vertexOutput.position;\n}\n</code></pre> varying.def.sc varying.def.sc<pre><code>vec4 a_color0    : COLOR0;\nvec2 a_texcoord1 : TEXCOORD1;\nvec3 a_position  : POSITION;\nvec2 a_texcoord0 : TEXCOORD0;\n\nvec4 i_data1 : TEXCOORD7;\nvec4 i_data2 : TEXCOORD6;\nvec4 i_data3 : TEXCOORD5;\n\nvec4          v_color0     : COLOR0;\nvec4          v_fog        : COLOR2;\nvec2          v_lightmapUV : TEXCOORD1;\ncentroid vec2 v_texcoord0  : TEXCOORD0;\nvec3          v_worldPos   : TEXCOORD3;\n</code></pre>"},{"location":"guide/#projectjson","title":"project.json","text":"<p>Now let's fill the project.json file:</p> project.json<pre><code>{\n  \"base_profile\": {\n    \"platforms\": [\n      \"Direct3D_SM40\",\n      \"Direct3D_SM50\",\n      \"Direct3D_SM60\",\n      \"Direct3D_SM65\",\n      \"ESSL_300\",\n      \"ESSL_310\"\n    ],\n    \"merge_source\": [\"../vanilla\"]\n  },\n  \"profiles\": {\n    \"windows\": {\n      \"platforms\": [\n        \"Direct3D_SM40\",\n        \"Direct3D_SM50\",\n        \"Direct3D_SM60\",\n        \"Direct3D_SM65\"\n      ]\n    },\n    \"android\": {\n      \"platforms\": [\"ESSL_300\", \"ESSL_310\"]\n    }\n  }\n}\n</code></pre> <p>This project config targets windows and android platforms by default, but also adds separate profiles for them, which allows you to choose which platform to compile to using <code>--profile</code> argument.</p> <p>Compiling Windows shaders</p> <p>Due to shaderc compiler limitations, you can only compile shaders for Windows (<code>Direct3D</code>) on a Windows machine. If you are following this tutorial on other OS then you won't be able to compile shaders for Windows.</p>"},{"location":"guide/#adding-shader-effects","title":"Adding shader effects","text":"<p>Currently our shader is exactly the same as vanilla and doesn't do anything different, so let's add some interesting effects!</p> <p>Edit the <code>main()</code> function in <code>fragment.sc</code> and add the highlighted line at the very bottom:</p> fragment.sc<pre><code>void main() {\n    FragmentInput fragmentInput;\n    FragmentOutput fragmentOutput;\n    fragmentInput.color0 = v_color0;\n    fragmentInput.fog = v_fog;\n    fragmentInput.lightmapUV = v_lightmapUV;\n    fragmentInput.texcoord0 = v_texcoord0;\n    fragmentInput.worldPos = v_worldPos;\n    fragmentOutput.Color0 = vec4(0, 0, 0, 0);\n    ViewRect = u_viewRect;\n    Proj = u_proj;\n    View = u_view;\n    ViewTexel = u_viewTexel;\n    InvView = u_invView;\n    InvProj = u_invProj;\n    ViewProj = u_viewProj;\n    InvViewProj = u_invViewProj;\n    PrevViewProj = u_prevViewProj;\n    {\n        WorldArray[0] = u_model[0];\n        WorldArray[1] = u_model[1];\n        WorldArray[2] = u_model[2];\n        WorldArray[3] = u_model[3];\n    }\n    World = u_model[0];\n    WorldView = u_modelView;\n    WorldViewProj = u_modelViewProj;\n    PrevWorldPosOffset = u_prevWorldPosOffset;\n    AlphaRef4 = u_alphaRef4;\n    AlphaRef = u_alphaRef4.x;\n    StandardTemplate_Opaque_Frag(fragmentInput, fragmentOutput);\n    fragmentOutput.Color0.rgb = vec3(1, 1, 1) - fragmentOutput.Color0.rgb; // Invert colors.\n    gl_FragColor = fragmentOutput.Color0;\n}\n</code></pre> <p>This will invert terrain colors.</p>"},{"location":"guide/#compilation","title":"Compilation","text":"<p>Now, we're finally ready to compile the project!</p> <p>Run the following command (optionally, with <code>-p windows</code>, <code>-p android</code> or <code>-p windows, android</code>, depending on which platforms you wish to compile for):</p> <pre><code>lazurite build ./helloWorld\n</code></pre> <p>And it should compile shaders into material, generating a final <code>RenderChunk.material.bin</code> file in the project <code>helloWorld</code> directory. Now you're ready to try out your shader in-game! If everything was done correctly, you should be able to see the inverted colors effect on blocks.</p>"},{"location":"material/","title":"Material Format","text":"<p>Unpacked material has the following file structure:</p> <pre><code>MyMaterial/\n\u251c\u2500 material.json\n\u251c\u2500 uniforms/\n\u2502  \u251c\u2500 ...\n\u2502  \u251c\u2500 MyUniform.json\n\u251c\u2500 buffers/\n\u2502  \u251c\u2500 ...\n\u2502  \u251c\u2500 MyBuffer.json\n\u251c\u2500 passes/\n\u2502  \u251c\u2500 ...\n\u2502  \u251c\u2500 MyPass.json\n\u2502  \u251c\u2500 MyPass/\n\u2502  \u2502  \u251c\u2500 ...\n\u2502  \u2502  \u251c\u2500 0.ESSL_310.Fragment.glsl\n</code></pre>"},{"location":"material/#material-schema","title":"Material Schema","text":"<p>material.json</p> <pre><code>{\n  \"version\": 22,\n  \"name\": \"RenderChunk\",\n  \"parent\": \"\",\n  \"buffers\": [\"LightMapTexture\", \"MatTexture\", \"SeasonsTexture\"],\n  \"uniforms\": [\n    \"SubPixelOffset\",\n    \"GlobalRoughness\",\n    \"FogAndDistanceControl\",\n    \"FogColor\",\n    \"LightDiffuseColorAndIlluminance\",\n    \"RenderChunkFogAlpha\",\n    \"LightWorldSpaceDirection\",\n    \"MaterialID\",\n    \"ViewPositionAndTime\",\n    \"MyAwesomeUniform\"\n  ],\n  \"uniform_overrides\": {\n    \"MyAwesomeUniform\": \"BUILTIN_MinecraftCameraPosition\"\n  },\n  \"passes\": [\n    \"DepthOnlyOpaque\",\n    \"AlphaTest\",\n    \"DepthOnly\",\n    \"Opaque\",\n    \"Transparent\"\n  ]\n}\n</code></pre> Property Description Allowed values or types <code>version</code> Material format version integer, see supported versions <code>name</code> Material name string <code>parent</code> Parent material name string <code>buffers</code> List of buffer names list of strings <code>uniforms</code> List of uniform names list of strings <code>uniform_overrides</code> List of uniform overrides dictionary of strings <code>passes</code> List of pass names list of strings"},{"location":"material/#uniform_overrides","title":"uniform_overrides","text":"<p>This field enables overriding behavior of existing uniforms in the material. Specifying override ID per uniform changes the behavior of that uniform.</p> <p>For example, if you want uniform <code>MyAwesomeUniform</code> to return camera position, and <code>FogColor</code> to return cloud color, it can be achieved in the following way:</p> <pre><code>\"uniform_overrides\": {\n  \"MyAwesomeUniform\": \"BUILTIN_MinecraftCameraPosition\",\n  \"FogColor\": \"BUILTIN_MinecraftCloudColor\"\n}\n</code></pre> <p>Below is a list of built-in (vanilla) uniform override IDs.</p> Override ID Notes BUILTIN_MinecraftBiomeID Biome ID (integer). List of biome IDs is available here BUILTIN_MinecraftCloudHeight Y coordinate of where the clouds layer begins BUILTIN_MinecraftDay Current day count BUILTIN_MinecraftDimensionID 0 - overworld, 1 - nether, 2 - end BUILTIN_MinecraftLocalClientID Unknown, probably some kind of unique integer ID per player that can be accessed from scripting API BUILTIN_MinecraftMoonIntensity Moon intensity from vibrant visuals (1 if VV is disabled) BUILTIN_MinecraftMoonPhase FULL_MOON=0, WANING_GIBBOUS=1, FIRST_QUARTER=2, WANING_CRESCENT=3, NEW_MOON=4, WAXING_CRESCENT=5, LAST_QUARTER=6, WAXING_GIBBOUS=7 BUILTIN_MinecraftRenderDistance Render distance (in blocks) BUILTIN_MinecraftSunIntensity Sun intensity from vibrant visuals (1 if VV is disabled) BUILTIN_MinecraftTimeOfDay 0 - noon, 0.25 - sunset, 0.5 - midnight, 0.75 - sunrise BUILTIN_MinecraftElapsedFrameTime Frame time (1/fps) BUILTIN_MinecraftWeatherID 0 - clear, 1 - rain, 2 - snow BUILTIN_MinecraftCameraFacingDirection BUILTIN_MinecraftCameraPosition BUILTIN_MinecraftLastCameraFacingDirection Camera direction from last frame BUILTIN_MinecraftLastCameraPosition Camera position from last frame BUILTIN_MinecraftSunDirection BUILTIN_MinecraftCloudColor BUILTIN_MinecraftFogColor BUILTIN_MinecraftMoonColor Moon color from vibrant visuals (1 if VV is disabled) BUILTIN_MinecraftSunColor Sun color from vibrant visuals (1 if VV is disabled)"},{"location":"material/#buffer-schema","title":"Buffer Schema","text":"<pre><code>{\n  \"name\": \"PBRData\",\n  \"reg1\": 2,\n  \"reg2\": 2,\n  \"type\": \"structBuffer\",\n  \"precision\": \"lowp\",\n  \"access\": \"readonly\",\n  \"texture_format\": \"\",\n  \"default_texture\": \"\",\n  \"unordered_access\": true,\n  \"always_one\": 1,\n  \"texture_path\": \"\",\n  \"sampler_state\": {\n    \"filter\": \"Point\",\n    \"wrapping\": \"Clamp\"\n  },\n  \"custom_type_info\": {\n    \"struct\": \"PBRTextureData\",\n    \"size\": 64\n  }\n}\n</code></pre> Property Description Allowed values or types Details <code>name</code> Buffer name string <code>reg1</code> Register or binding integer Same as reg2 <code>reg2</code> Register or binding integer Same as reg1 <code>type</code> Buffer type <code>texture2D</code> <code>texture2DArray</code> <code>external2D</code> <code>texture3D</code> <code>textureCube</code> <code>textureCubeArray</code> <code>structBuffer</code> <code>rawBuffer</code> <code>accelerationStructure</code> <code>shadow2D</code> <code>shadow2DArray</code> <code>precision</code> Buffer precision <code>lowp</code> <code>mediump</code> <code>highp</code> <code>access</code> Buffer access type <code>undefined</code> <code>readonly</code> <code>writeonly</code> <code>readwrite</code> <code>texture_format</code> Texture format Arbitrary string, possible values include (but not limited to): (empty string) <code>r32ui</code> <code>rg32ui</code> <code>rgba32ui</code> <code>r32f</code> <code>r16f</code> <code>rg16f</code> <code>rgba16f</code> <code>rgba8</code> <code>rg8</code> <code>r8</code> <code>rgba32f</code> <code>float</code> <code>int</code> <code>uint</code> Possible values were extracted from bgfx_compute.sh <code>default_texture</code> Default texture (unknown what it does) string (empty string means that the buffer doesn't have this property) The only observed value in the game was <code>white</code> <code>unordered_access</code> Enables unordered access (UBO) bool <code>always_one</code> Unknown (must always be 1, otherwise buffer breaks) integer All materials have a value of 1 <code>texture_path</code> Specifies texture that will be used by this buffer. Example: <code>textures/environment/sun</code> string (empty string means that the buffer doesn't have this property) <code>sampler_state</code> Overwrites sampler state properties enum. If set to empty object <code>{}</code> that means that the buffer doesn't have this property <code>custom_type_info</code> Information about custom structured buffer (SSBO) type enum. If set to empty object <code>{}</code> that means that the buffer doesn't have this property Changing Buffer Registers <p>The difference between <code>reg1</code> and <code>reg2</code> is unknown, in the material files they always have the same value. Lazurite uses <code>reg1</code> for setting AUTOREG macros, however the game seems to be using <code>reg2</code> for deciding which register to actually use. Therefore it is recommended to set both properties when changing buffer register or binding.</p>"},{"location":"material/#sampler_state","title":"sampler_state","text":"Property Description Allowed values or types <code>filter</code> Texture filter <code>Point</code> <code>Bilinear</code> <code>wrapping</code> Texture wrapping <code>Clamp</code> <code>Repeat</code>"},{"location":"material/#custom_type_info","title":"custom_type_info","text":"Property Description Allowed values or types <code>struct</code> Struct name string <code>size</code> Struct size (in bytes) integer"},{"location":"material/#uniform-schema","title":"Uniform Schema","text":"<pre><code>{\n  \"name\": \"GlobalRoughness\",\n  \"type\": \"vec4\",\n  \"count\": 1,\n  \"default\": [0.5, 0.5, 0.5, 0.5]\n}\n</code></pre> Property Description Allowed values or types Details <code>name</code> Uniform name string <code>type</code> Uniform type <code>vec4</code> <code>mat3</code> <code>mat4</code> <code>external</code> <code>count</code> Number of array elements integer (1 if uniform is not an array) For example, in case of <code>uniform vec4 Bones[5];</code> it would be 5 <code>default</code> Default value list of floats 4 elements for <code>vec4</code>, 9 for <code>mat3</code>, 16 for <code>mat4</code>"},{"location":"material/#pass-schema","title":"Pass schema","text":"<pre><code>{\n  \"name\": \"ColorPostProcess\",\n  \"supported_platforms\": {\n    \"Direct3D_SM40\": true,\n    \"Direct3D_SM50\": true,\n    \"Direct3D_SM60\": true,\n    \"Direct3D_SM65\": true,\n    \"Direct3D_XB1\": true,\n    \"Direct3D_XBX\": true,\n    \"GLSL_120\": true,\n    \"GLSL_430\": true,\n    \"ESSL_300\": true,\n    \"ESSL_310\": true,\n    \"Metal\": true,\n    \"Vulkan\": true,\n    \"Nvn\": true,\n    \"PSSL\": true,\n    \"Unknown\": true\n  },\n  \"fallback_pass\": \"Fallback\",\n  \"default_blend_mode\": \"\",\n  \"default_variant\": {\n    \"AlphaTest\": \"On\"\n  },\n  \"framebuffer_binding\": 0,\n  \"variants\": [\n    {\n      \"is_supported\": true,\n      \"flags\": {\n        \"AlphaTest\": \"On\"\n      },\n      \"shaders\": [\n        {\n          \"file_name\": \"0.ESSL_300.Fragment.glsl\",\n          \"stage\": \"Fragment\",\n          \"platform\": \"ESSL_300\",\n          \"inputs\": [\n            {\n              \"name\": \"texcoord0\",\n              \"type\": \"vec2\",\n              \"semantic\": \"TEXCOORD0\",\n              \"per_instance\": false,\n              \"precision\": \"\",\n              \"interpolation\": \"\"\n            }\n          ],\n          \"hash\": 6879661314034565044,\n          \"bgfx_shader\": {\n            \"hash\": 1010703983,\n            \"uniforms\": [\n              {\n                \"name\": \"ExposureCompensation\",\n                \"type_bits\": 2,\n                \"count\": 1,\n                \"reg_index\": 0,\n                \"reg_count\": 1\n              }\n            ],\n            \"group_size\": [],\n            \"attributes\": [],\n            \"size\": -1\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre> Property Description Allowed values or types Details <code>name</code> Shader pass name string <code>supported_platforms</code> Platforms that support this pass dictionary with platforms as keys and bool as values Unsupported platforms will not render this pass and instead use fallback_pass (if defined) <code>fallback_pass</code> Name of the fallback pass string This pass will be used if current pass is unsupported <code>default_blend_mode</code> Unknown (empty string) <code>NoneMode</code> <code>Replace</code> <code>AlphaBlend</code> <code>ColorBlendAlphaAdd</code> <code>PreMultiplied</code> <code>InvertColor</code> <code>Additive</code> <code>AdditiveAlpha</code> <code>Multiply</code> <code>MultiplyBoth</code> <code>InverseSrcAlpha</code> <code>SrcAlpha</code> Empty string indicates that shader pass doesn't have this property <code>default_variant</code> Default variant flags Dictionary of strings Variant with specified flags will be used as default, if the game fails to find a variant with requested flags in the material <code>framebuffer_binding</code> Unique framebuffer cnfiguration ID integer Exact behavior or meaning is unknown, but at this time it is not a useful property to modify for shader developers. <code>variants</code> List of variants See variant schema for details"},{"location":"material/#variant","title":"variant","text":"Property Description Allowed values or types <code>is_supported</code> Unknown bool <code>flags</code> Dictionary with <code>flag: value</code> pairs Dictionary of strings <code>shaders</code> List of individual shader definitions"},{"location":"material/#shader","title":"shader","text":"Property Description Allowed values or types <code>file_name</code> Name of the file with compiled shader (in <code>material/passes/&lt;pass name&gt;/</code>) string <code>stage</code> Shader pipeline stage <code>Vertex</code> <code>Fragment</code> <code>Compute</code> <code>Unknown</code> <code>platform</code> List of platforms See possible values here <code>hash</code> Unknown 64bit unsigned int <code>inputs</code> List of input (attributes or varyings) definitions Details here <code>bgfx_shader</code> Data of BGFX compiled shader Undocumented"},{"location":"material/#input","title":"input","text":"Property Description Allowed values or types Details <code>name</code> Input name string <code>type</code> Input type <code>float</code> <code>vec2</code> <code>vec3</code> <code>vec4</code> <code>int</code> <code>ivec2</code> <code>ivec3</code> <code>ivec4</code> <code>uint</code> <code>uvec2</code> <code>uvec3</code> <code>uvec4</code> <code>mat4</code> <code>semantic</code> Input semantic <code>POSITION</code> <code>NORMAL</code> <code>TANGENT</code> <code>BITANGENT</code> <code>COLOR</code> <code>BLENDINDICES</code> <code>BLENDWEIGHT</code> <code>TEXCOORD</code> <code>UNKNOWN</code> <code>FRONTFACING</code> Semantic string is also alowed to end with an integer index e.g. <code>COLOR1</code>, <code>TEXCOORD3</code>. If no index is provides, it is assumed to be 0. <code>per_instance</code> Indicates if input is instance data bool Typically it's only set to true for <code>instanceData</code> attribute. <code>precision</code> Precision qualifier (empty string) <code>lowp</code> <code>mediump</code> <code>highp</code> Empty string indicates that shader input doesn't have this property. <code>interpolation</code> Interpolation qualifier (empty string) <code>flat</code> <code>smooth</code> <code>noperspective</code> <code>centroid</code> Empty string indicates that shader input doesn't have this property."},{"location":"platforms/","title":"Platforms","text":"Platform OS / Device Notes <code>Direct3D_SM40</code> Windows <code>Direct3D_SM50</code> Windows <code>Direct3D_SM60</code> Windows <code>Direct3D_SM65</code> Windows <code>Direct3D_XB1</code> Xbox One <code>Direct3D_XBX</code> Xbox X <code>GLSL_120</code> ? <code>GLSL_430</code> ? <code>ESSL_300</code> Android Removed in <code>.material.bin</code> format version <code>25</code> <code>ESSL_310</code> Android <code>Metal</code> iOS <code>Vulkan</code> Switch <code>Nvn</code> Switch (future) <code>PSSL</code> PlayStation <code>Unknown</code> ?"},{"location":"project/","title":"Projects","text":"<p>\"Projects\" in lazurite represent a group of related materials that will be compiled and packaged together. Thinking about shaders as projects rather than individual materials allows for easier development, greater code reusability across projects and in general it just makes more sense. Projects in lazurite are compiled using the build command.</p> <p>Compiling shaders</p> <p>You need a shader compiler executable in order to compile shaders from source code. See build command for details about available compilers.</p>"},{"location":"project/#project-file-structure","title":"Project file structure","text":"<p>Project is a folder that may contain <code>project.json</code> and unpacked materials (see material format). Each material can also additionally contain <code>config.json</code> and <code>shaders/</code> folder with shader source code (can be changed in <code>config.json</code>).</p> <pre><code>myProject/\n\u251c\u2500 Actor/\n\u2502  \u251c\u2500 ...\n\u251c\u2500 RenderChunk/\n\u2502  \u251c\u2500 ...\n\u2502  \u251c\u2500 config.json\n\u251c\u2500 project.json\n</code></pre>"},{"location":"project/#projectjson","title":"project.json","text":"<p>This file is used for configuring project-wide settings, which are represented with profiles. Custom profiles can be activated when using a build command, with a <code>--profile</code> argument.</p> <pre><code>{\n  \"base_profile\": {\n    \"macros\": [\"DEBUG\", \"FOCAL_LENGTH 12.5\"],\n    \"platforms\": [\"Direct3D_SM65\", \"ESSL_310\"],\n    \"merge_source\": [\"../../vanilla/windows/\"],\n    \"include_patterns\": [\"*\"],\n    \"exclude_patterns\": [\".*\", \"_*\"],\n    \"include_search_paths\": [\"include\"]\n  },\n  \"profiles\": {\n    \"profileExample\": {\n      \"macros\": [\"DEBUG\", \"FOCAL_LENGTH 12.5\"],\n      \"platforms\": [\"Direct3D_SM65\", \"ESSL_310\"],\n      \"merge_source\": [\"../../vanilla/windows/\"],\n      \"include_patterns\": [\"*\"],\n      \"exclude_patterns\": [\".*\", \"_*\"],\n      \"include_search_paths\": [\"include\"]\n    }\n  }\n}\n</code></pre> Property Description <code>base_profile</code> Base profile <code>profiles</code> Custom profiles"},{"location":"project/#profile-schema","title":"Profile schema","text":"Property Description <code>macros</code> List of macros <code>platforms</code> List of platforms targetted by the project <code>merge_source</code> List of individual materials or folders with materials that will be used for merging. Supports both <code>.material.bin</code> and <code>.material.json</code> files <code>include_patterns</code> List of glob patterns used for searching material folders in a project, by default <code>[\"*\"]</code> <code>exclude_patterns</code> List of glob patterns that exclude folders in a project from being considered as material folders, by default <code>[\".*\", \"_*\"]</code> <code>include_search_paths</code> List of <code>#include</code> search paths <p>Glob patterns</p> <p>Glob pattern support is provided by pathlib python library, which also adds an additional <code>**</code> syntax for recursive matches.</p> <p>Default file patterns</p> <p>With default values of <code>include_patterns</code> set to <code>[\"*\"]</code> and <code>exclude_patterns</code> set to <code>[\".*\", \"_*\"]</code>, all folders in project root will be considered as material folders, unless they start with a dot <code>.</code> or an underscore <code>_</code>. Even if the folder is empty or doesn't have any meaningful data, it will still be compiled and generate a material in the end.</p>"},{"location":"project/#profile-merging-rules","title":"Profile merging rules","text":"<p>When building a project, multiple profiles can be specified at the same time, properties of which then will be merged together. In general, profile merging rules can be described as follows:</p> <ol> <li>Properties from custom profiles are added together.</li> <li>Base profile property is only used if none of the activated custom profiles overwrite that property.</li> </ol> <p>For example, if base profile specifies platforms for android and windows, and you don't activate any custom profiles, project will be compiled for both platforms. But if you activate custom ios profile, which only has an ios platform, then project will be compiled only for ios. But if you activate both android and ios profiles, their platforms will be added together and project will now be compiled for ios and android.</p> <p>This approach allows to support numerous use cases using the same simple rules. For example, you can have profiles for individual versions (release, preview) that change <code>merge_source</code>, profiles for specific platforms (<code>platforms</code>), features or configs (<code>macros</code>), inclusion or exclusion of specific materials (<code>include_patterns</code>, <code>exclude_patterns</code>).</p>"},{"location":"project/#configjson","title":"config.json","text":"<p>This file contains per-material compilaton settings.</p> <pre><code>{\n  \"compiler\": {\n    \"type\": \"dxc\",\n    \"options\": [\"-no-warnings\"]\n  },\n  \"supported_platforms\": [\"Direct3D_SM65\", \"ESSL_310\"],\n  \"macro_overwrite\": {\n    \"flags\": {\n      \"Fancy\": {\n        \"On\": \"FANCY\",\n        \"Off\": []\n      }\n    },\n    \"passes\": {\n      \"Transparent\": \"TRANSPARENT\",\n      \"AlphaTest\": [\"ALPHA_TEST\"]\n    }\n  },\n  \"file_overwrite\": {\n    \"default\": {\n      \"entry_point\": \"main\",\n      \"fragment\": \"shaders/fragment.sc\",\n      \"vertex\": \"shaders/vertex.sc\",\n      \"compute\": \"shaders/compute.sc\",\n      \"unknown\": \"shaders/unknown.sc\",\n      \"varying\": \"shaders/varying.def.sc\"\n    },\n    \"passes\": {\n      \"Transparent\": {\n        \"entry_point\": \"main\",\n        \"fragment\": \"shaders/fragment.sc\",\n        \"vertex\": \"shaders/vertex.sc\",\n        \"compute\": \"shaders/compute.sc\",\n        \"unknown\": \"shaders/unknown.sc\",\n        \"varying\": \"shaders/varying.def.sc\"\n      }\n    }\n  }\n}\n</code></pre> Property Description <code>compiler</code> Compiler settings. <code>type</code> can be <code>dxc</code> (for RTX shaders) or <code>shaderc</code> (for BGFX shaders). <code>shaderc</code> is the default compiler. <code>options</code> is a list of additional aguments that will be passed to the compiler <code>supported_platforms</code> List of platforms supported by material. By default, all platforms are supported <code>macro_overwrite</code> Allows to overwrite autogenerated flag or pass macros <code>file_overwrite</code> Allows to overwrite shader file paths and compute entry point per pass or globally. Note that entry point overwrite is only supported for DXC compiler Macro generation rules <p>Both passes and flags are formatted from camel case to snake case, according to the following rules:</p> <ol> <li>aA -&gt; a_A (insert underscore before a new word begins)</li> <li>AAa -&gt; A_Aa (insert underscore before a new word begins, if previous ended in capital letter)</li> <li>00X -&gt; 00_X (insert underscore after a number)</li> </ol> <p>After formatting, pass names are appended with <code>_PASS</code> (unless they already end with it), while flag names and keys are joined with a double underscore <code>__</code>.</p> <p>For example, <code>AlphaTest</code> pass will generate as <code>ALPHA_TEST_PASS</code> while <code>Emissive</code> flag with a value of <code>EmissiveOnly</code> with generate as <code>EMISSIVE__EMISSIVE_ONLY</code></p> Default file overwrites <p>If not specified, the following file paths are used by default: <code>shaders/fragment.sc</code>, <code>shaders/vertex.sc</code>, <code>shaders/compute.sc</code>, <code>shaders/unknown.sc</code>, <code>shaders/varying.def.sc</code>.</p> <p>Default entry point value is empty string, which means that entry point name will be equal to shader pass name.</p>"},{"location":"project/#compilation-pipeline","title":"Compilation pipeline","text":"<p>Platforms specified in project and material configs are very important during compilation. Think of project platforms as platforms that you wish to target with your project, while material platforms are platforms that a specific material can be compiled for. Project is compiled one material at a time.</p> <p>At first, lazurite loads and merges together all materials from merge paths which have at least one platform from a list of <code>platforms</code> in project config. Materials are chosen for merging if they have the same material name, if it's specified in material.json, otherwise they are merged if they have a base file name that matches folder name of the material in a project. Output material will always have the same file name as material folder in the project. If no materials with matching platforms can be found, it will instead merge materials with any platforms.</p> <p>If the final merged material doesn't have all compileable platforms (platforms that are both in project and material configs), remaining platforms will be added to it automatically, so having vanilla materials for every platform is not necessary and only one platform is enough. Any platforms that are not in the project config will be removed.</p> <p>As a result, final material will compile shaders only for platforms that are both in project and material configs and for the remaining platforms in project config, vanilla shaders will be used (if available in merge source materials).</p> <p>Then the resulting material gets additionally merged with any material data in the project material folder. This allows you to make any targetted changes that will overwrite properties of the final material.</p> <p>Shaders will be compiled for platforms that are both in project and material config.</p> Automatic register binding <p>Did you know? Lazurite passes buffer registers as macros to both SHADERC and DXC compilers. The format is <code>s_&lt;BufferName&gt;_REG</code>, for example <code>s_MatTexture_REG</code>. If you are using the following bgfx_shader.sh or bgfx_compute.sh, you can even use AUTOREG macros that automatically set registers and bindings to that macro, based only on buffer name.</p>"},{"location":"project/#material-changes-merging-rules","title":"Material changes merging rules","text":"<p>As mentioned previously, you can specify individual changes instead of the whole material in a project material folder, and those changes will be applied to the final material after merging, but before compiling shaders.</p> <p>In general, any fields that you specify will overwrite fields of the source material. For example, if you have just a material.json with only a <code>parent</code> property inside, it will only change the name of the material parent and nothing else. Overwriting properties of uniforms, buffers or passes can be done in the same way, except if the <code>name</code> in a uniform, buffer or pass json file is provided, it will modify an object with the same name. But if the name is not provided, it will instead treat filename as a name of object to be modified. If the object cannot be found by name, it will instead be appended to the material, which allows to easily add new buffers, passes or uniforms, by adding new json files, no material.json editing is required (so no need to specify <code>uniforms</code>, <code>buffers</code> or <code>passes</code>). Although deleting any objects can only be done by specifying a list of names in material.json with unwanted entries removed. A manual overwrite of material.json takes priority over additional objects that are added into their respective folders.</p> <p>Warning</p> <p>Changing properties of individual variants, including replacing compiled shaders is currently unsupported. You have to provide full data from <code>variants</code> object in a shader pass json file, as well as all files with compiled shaders from that shader pass.</p> <p>Encryption</p> <p>If any of the merge sources for a specific material are encrypted, compiled material will also be encrypted. This is necessary to protect 3rd party IP, which in turn protects this project from potential legal action.</p>"},{"location":"project/#glsl-validation","title":"GLSL validation","text":"<p>When compiling OpenGL shaders, shaderc doesn't always validate resulting code, especially when compiling for platforms that don't support GLSL optimization like ESSL 310. This could lead to improper shader code, which fails to compile on device and crashes the game. To avoid this, lazurite offsers multiple optional ways to validate your shader code during compilation.</p>"},{"location":"project/#glslang","title":"Glslang","text":"<p>Glslang is the official reference compiler front end for the OpenGL ES and OpenGL shading languages. It implements a strict interpretation of the specifications for these languages.</p> <p>When compiling a lazurite project, you can specify glslang path or command via <code>--glslang</code> argument in the build command. Note that this argument has a default value, which would try to call <code>glslang</code> in the current directory.</p> <p>On Linux (or Termux), it can be installed from a package manager, for example</p> <pre><code>apt install glslang\n</code></pre> <p>On Windows and macOS, you can download glslang executables from here</p>"},{"location":"project/#moderngl","title":"ModernGL","text":"<p>ModernGL is a Python library that provides access to OpenGL API. Lazurite interfaces with OpenGL in order to try and compile resulting GLSL code and catch compilation errors, if any occur.</p> <p>ModernGL can be installed the same as any other Python library</p> <pre><code>pip install moderngl\n</code></pre> <p>Alternatively, you can install both lazurite and moderngl by running</p> <pre><code>pip install lazurite[opengl]\n</code></pre> Running moderngl in Termux <p>Moderngl doesn't work right out of the box in Termux, and requires extra steps to use and install.</p> <p>Install necessary packages</p> <p><pre><code>pgk i mesa xorgproto libx11 x11-repo &amp;&amp; pkg i termux-x11-nightly\n</code></pre> Install lazurite</p> <p><pre><code>pip install lazurite[opengl]\n</code></pre> Install Termux-x11 companion app from https://github.com/termux/termux-x11 (see Setup Instructions)</p> <p>Then start X11 server</p> <pre><code>termux-x11 :1 &amp;\n</code></pre> <p>After that you can run lazurite build command, by prefixing it with <code>DISPLAY=:1</code> like so</p> <p><pre><code>DISPLAY=:1 lazurite build myAwesomeShader\n</code></pre> You will need to launch X11 server before you intend to use GLSL validation capability. Note that the server will remain running in the background, and most of the time you need to start it only once, when you begin a Termux session.</p> <p>Glslang enforces official GLSL specification which should work on all devices, although it may not fully support validation for all GLSL features in certain versions. ModernGL on the other hand compiles GLSL right on device, which means that it will use vendor specific validation, and may not catch errors that can occur on other devices, but it should support all GLSL features. It is therefore recommended to use both validators if possible.</p>"},{"location":"supported_versions/","title":"Supported Versions","text":"<p>This page documents <code>.material.bin</code> file format versions supported by Lazurite - material version number and which Bedrock release and preview versions it applies to.</p> Older Versions <p>Despite materials prior to <code>1.21.110</code> also having a format version number of <code>22</code>, they are not supported by latest versions of Lazurite because they have a different format despite sharing the same format version. If you wish to work with older <code>.material.bin</code> formats, older Lazurite versions are required - https://github.com/veka0/lazurite/releases</p>"},{"location":"supported_versions/#format-versions","title":"Format Versions","text":"Material Version Initial Release Initial Preview <code>22</code> <code>1.21.111.1</code> <code>1.21.110.20</code> <code>23</code> <code>1.26.0.2</code> <code>1.26.0.23</code> <code>25</code> - <code>1.26.10.20</code>"}]}